- [学习记录](#学习记录)
  - [第一章 Git的学习](#第一章-git的学习)
    - [1.1 Git的工作流程](#11-git的工作流程)
    - [1.2 Git工作区、暂存区和版本库](#12-git工作区暂存区和版本库)
    - [1.3 Git创建仓库](#13-git创建仓库)
    - [1.4 Git的基本操作](#14-git的基本操作)
    - [1.5 Git的分支管理](#15-git的分支管理)
    - [1.6 Git标签](#16-git标签)
    - [1.7 Github实操](#17-github实操)
  - [第二章 Linux 学习](#第二章-linux-学习)
    - [2.1 文件的属性](#21-文件的属性)
    - [2.2 目录的操作](#22-目录的操作)
    - [2.3 Vim的使用](#23-vim的使用)
    - [2.4 Shell的使用](#24-shell的使用)
  - [第三章 Docker学习](#第三章-docker学习)
    - [3.1 成功在Ubuntu上安装Docker](#31-成功在ubuntu上安装docker)
    - [3.2 成功安装mysql](#32-成功安装mysql)
    - [3.3 成功安装redis](#33-成功安装redis)
  - [第四章 在python中使用mysql](#第四章-在python中使用mysql)
    - [4.1 使用SQLAlchemy Core](#41-使用sqlalchemy-core)
      - [4.1.1 定义元数据和表然后连接](#422-定义元数据和表然后连接)
      - [4.1.2 增](#423-增)
    - [4.2 使用SQLAlchemy ORM](#43-使用sqlalchemy-orm)
    - [4.3 一对多与多对多关系](#44-一对多与多对多关系)
  - [第五章 threading基于线程的并行](#第五章-threading基于线程的并行)
    - [5.1 基本概念](#51-基本概念)
    - [5.2 Thread类](#52-thread类)
    - [5.3 RLock类](#53-rlock类)
    - [5.4 线程锁](#54-线程锁)
    - [5.5 前台线程与后台线程](#55-前台线程与后台线程)
    - [5.6 练习](#56-练习)
  - [第六章 redis](#第六章-redis)
    - [6.1 基础操作](#61-基础配置)
    - [6.2 增删查改操作](#62-增删查改操作)
    - [6.3 进阶操作](#63-进阶操作)
    
    


# 学习记录
## 第一章 Git的学习
### 1.1 Git的工作流程
  Git的主要功能在于我们能从已有的数据库中克隆工作副本，并且修改后再次上传

### 1.2 Git工作区暂存区和版本库
  工作区：你在电脑里能看到的目录
  暂存区：一般存放在 .git 目录下的 index 文件（.git/index）中

  当对工作区修改（或新增）的文件执行 **git add** 命令时，暂存区的目录树被更新
  当执行提交操作 **git commit**时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。
  当执行 **git reset HEAD** 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。
  当执行 **git rm --cached <file>** 命令时，会直接从暂存区删除文件，工作区则不做出改变。

### 1.3 Git创建仓库
  (1) **git init** 初始化，生成一个 .git 目录  
  (2) 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：  
  $ git add *.c  
  $ git add README  
  $ git commit -m '初始化项目版本'  
  (3) 克隆操作 git clone <repo> <directory> repo:Git 仓库 directory:本地目录  

### 1.4 Git的基本操作
  **git add**	添加文件到暂存区  
  **git status**	查看仓库当前的状态，显示有变更的文件。  
  **git diff**	比较文件的不同，即暂存区和工作区的差异。  
  **git commit**	提交暂存区到本地仓库。  
  **git reset**	回退版本。  
  **git rm**	将文件从暂存区和工作区中删除。  
  **git mv**	移动或重命名工作区文件。
  **git checkout**	分支切换。


### 1.5 Git的分支管理
  (1) 创建分支 git branch  
  (2) 切换分支 git checkout  
  (3) 列出分支 git branch  
  (4) 删除分支 git branch -d (branchname)  

### 1.6 Git标签
  $ git tag -a v1.0  -a 选项意为"创建一个带注解的标签

### 1.7 Github实操
  成功在本地克隆git仓库，并且实现代码的上传与下载！

存在的疑问：使用 git merge 时，为什么会发生冲突，冲突该怎么解决?

## 第二章 Linux 学习  

### 2.1 文件的属性
当为 **d** 则是目录  
当为 **-** 则是文件  
若是 **l** 则表示为链接文档(link file)  
若是 **b** 则表示为装置文件里面的可供储存的接口设备  
若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标  

### 2.2 目录的操作
(1) **pwd**：显示目前的目录  
(2) **mkdir**：创建一个新的目录  
(3) **rmdir**：删除一个空的目录   
(4) **cp**: 复制文件或目录  
(5) **mv**: 移动文件与目录，或修改文件与目录的名称   

### 2.3 Vim的使用
基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）

### 2.4 Shell的使用
#### 2.4.1 传递参数
我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数

#### 2.4.2 使用定义好的变量
使用一个定义过的变量，只要在变量名前面加美元符号即可，echo $your_name

#### 2.4.3 Shell echo命令
用于字符串的输出: echo string

#### 2.4.4 Shell流程控制
if condition
then
    command1 
    command2
    ...
    commandN 
fi
其余的详细见讲解手册

### 总结
在ubuntu 系统中使用vim生成了.sh 文件，并且改变了其权限，并且完成了echo，数学运算等一系列操作

## 第三章 Docker学习
### 3.1 成功在Ubuntu上安装Docker
### 3.2 成功安装mysql

   通过docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql运行sql  ####不需要重复进行  
   通过docker start 02fdb64e0e51c9b9b23c087568444f58e8228a95d68e3d6f8ed009410c76fb33  进行激活  
   通过docker exec -it mysql-test mysql -u root -p 进入mysql内部

#### 3.2.1 mysql的命令
    1. 创建数据库： CREATE DATABASE my_database;  
    2. 选择数据库：USE my_database;  
    3. 创建表：CREATE TABLE my_table (  
    id INT AUTO_INCREMENT PRIMARY KEY,  
    name VARCHAR(255) NOT NULL,  
    age INT NOT NULL  
);  
    4. 插入数据：INSERT INTO my_table (name, age) VALUES ('Alice', 30);  
    5. 查询数据： SELECT * FROM my_table; SELECT name, age FROM my_table;  
    6. 更新数据: UPDATE my_table SET age = 31 WHERE name = 'Alice';  
    7. 删除表和数据库: DROP TABLE my_table; DROP DATABASE my_database;  
    8. 修改表结构：ALTER TABLE my_table ADD COLUMN email VARCHAR(255);



 ### 3.3 成功安装redis
    通过 docker start 838e0ee6499429cbc66eeef7579608bf61156ab182451ada706d87d8622c2e0f进行激活  
    通过 docker exec -it redis-test /bin/bash  进入内部，开始操作  
    通过 redis-cli进行激活， 然后就可以使用  

#### 3.3.1 redis命令
    1. 设置键值对：SET mykey "Hello, Redis"  
    2. 获取键值对：GET mykey  
    3. 检查键是否存在：EXISTS mykey  
    4. 添加元素到列表：LPUSH mylist "element1"  
                      LPUSH mylist "element2"  
    5. 获取列表中的元素：LRANGE mylist 0 -1
    6. 添加元素到集合： SADD myset "member1"  
                       SADD myset "member2"  
    7. 获取集合中的所有元素：SMEMBERS myset  
    8. 设置哈希字段： HSET myhash field1 "value1"  
                     HSET myhash field2 "value2"  
    9. 获取哈希字段：HGET myhash field1  
    10. 添加元素到有序集合：ZADD myzset 1 "member1"   
                          ZADD myzset 2 "member2"  
    11. 获取有序集合中的元素： ZRANGE myzset 0 -1 WITHSCORES  
    12. 获取有序集合中元素的排名：ZRANK myzset "member1"  
    
## 第四章 在python中使用mysql
### 4.1 使用SQLAlchemy Core
  SQLAlchemy Core包含了SQL 表达式语言和 SQL 构建器，可以直接与数据库进行交互。
    
  首先我们进行包的下载
  ```python
  pip install SQLAlchemy
  ```
#### 连接数据库
  ```python
  from sqlalchemy import create_engine

  # 创建数据库连接
  engine = create_engine('sqlite:///example.db', echo=True)
  ```
其中echo=True可以让我们查看日志，便于操作

#### 4.2.2 定义元数据和表然后连接
```python
from sqlalchemy import Table, Column, Integer, String, MetaData

metadata = MetaData()

users = Table('users', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String),
    Column('age', Integer)
)
# 创建表
metadata.create_all(engine)

# 创建连接
conn = engine.connect()
  ```
#### 4.2.3 增 

```python
from sqlalchemy import insert

# 单条插入
ins = users.insert().values(name='John Doe', age=30)
conn.execute(ins)

# 批量插入
conn.execute(users.insert(), [
    {'name': 'Alice', 'age': 28},
    {'name': 'Bob', 'age': 24},
    {'name': 'Charlie', 'age': 30}
])
  ```
#### 4.2.4 查
```python
from sqlalchemy import select

# 查询所有数据
s = select([users])
result = conn.execute(s)

for row in result:
    print(row)
  ```
输出为 :(1, 'John Doe', 30)  
(2, 'John Doe', 30)  
(3, 'Alice', 28)  
(4, 'Bob', 24)  
(5, 'Charlie', 30)  

#### 4.2.5 改
```python
from sqlalchemy import update

# 更新数据
upd = update(users).where(users.c.name == 'John Doe').values(age=35)
conn.execute(upd)
  ```
#### 4.2.6 删
```python
from sqlalchemy import delete

# 删除数据
del_stmt = delete(users).where(users.c.name == 'John Doe')
conn.execute(del_stmt)
  ```
### 4.3 使用SQLAlchemy ORM

#### 4.3.1 定义模型和创建表
```python
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import sessionmaker

# 创建数据库连接
engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

# 定义模型
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)

# 创建表
Base.metadata.create_all(engine)
  ```
#### 4.3.2 创建会话
```python
Session = sessionmaker(bind=engine)
session = Session()
2.3 增 (Insert)
  ```
#### 4.3.3 增

```python
new_user = User(name='Jane Doe', age=25)
session.add(new_user)
session.commit()

# 批量插入
users = [
    User(name='Alice', age=28),
    User(name='Bob', age=24),
    User(name='Charlie', age=30)
]
session.add_all(users)
session.commit()
  ```
在这里展示如何批量插入数据，同时也可以发现使用SQLAlchemy ORM非常的方便

#### 4.3.4 查
```python
# 查询所有数据
for user in session.query(User).all():
    print(user.name, user.age)

# 带条件查询
user = session.query(User).filter_by(name='Alice').first()
print(user.name, user.age)
  ```
可以通过filter_by来有针对性的查找数据

#### 4.3.5 改
```python
# 更新数据
user = session.query(User).filter_by(name='Alice').first()
user.age = 29
session.commit()
  ```
#### 4.3.6 删
```python
# 删除数据
user = session.query(User).filter_by(name='Bob').first()
session.delete(user)
session.commit()
  ```
### 4.4 一对多与多对多关系
#### 4.4.1 一对多关系
```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)
    addresses = relationship("Address", back_populates="user")

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="addresses")

# 创建表
Base.metadata.create_all(engine)

# 创建会话
Session = sessionmaker(bind=engine)
session = Session()

# 插入数据
new_user = User(name='John Doe', age=30, addresses=[
    Address(email_address='john.doe@example.com'),
    Address(email_address='john.doe@work.com')
])
session.add(new_user)
session.commit()

# 查询数据
user = session.query(User).filter_by(name='John Doe').first()
print(user.name, user.age)
for address in user.addresses:
    print(address.email_address)
  ```
在这个例子中，定义了一种一对多的关系：一个 User 可以有多个 Address，而一个 Address 只能属于一个 User

可以理解为 Address就是User的一个子集，而ForeignKey('users.id')代表了address受到 user中的id的制约，不能插入user中没有的id
```python
# 尝试插入一个无效的地址（无效的 user_id）
invalid_address = Address(email_address='invalid@example.com', user_id=999)
session.add(invalid_address)
try:
    session.commit()
except Exception as e:
    session.rollback()
    print(f"Error: {e}")
  ```
这样子做可以有效的放置插入到了没有用的部位

#### 4.4.1 多对多关系

需要一个关联表来实现多对多关系

```python
from sqlalchemy import Table

association_table = Table('association', Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id')),
    Column('group_id', Integer, ForeignKey('groups.id'))
)

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    groups = relationship("Group", secondary=association_table, back_populates="users")

class Group(Base):
    __tablename__ = 'groups'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    users = relationship("User", secondary=association_table, back_populates="groups")

# 创建会话
Session = sessionmaker(bind=engine)
session = Session()

# 插入学生
student1 = Student(name='Alice')
student2 = Student(name='Bob')

# 插入课程
course1 = Course(name='Mathematics')
course2 = Course(name='Physics')

# 建立多对多关系
student1.courses.append(course1)
student1.courses.append(course2)
student2.courses.append(course1)

# 保存到数据库
session.add(student1)
session.add(student2)
session.commit()

# 查询学生及其选修的课程
students = session.query(Student).all()
for student in students:
    print(f"Student: {student.name}")
    for course in student.courses:
        print(f"  Enrolled in: {course.name}")

# 查询课程及其选修的学生
courses = session.query(Course).all()
for course in courses:
    print(f"Course: {course.name}")
    for student in course.students:
        print(f"  Student: {student.name}")
  ```
多对多中最重要的是要有一个中间表，但是中间表并不需要呈现出来，极大的简化了操作
## 第五章 threading基于线程的并行
### 5.1 基本概念
  线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

  多线程允许在同一个进程中同时运行多个线程。多线程可以提高程序的效率，特别是在I/O操作频繁的情况下。

### 5.2 Thread类
  Thread类用于创建和管理线程。可以通过继承Thread类或直接实例化并传入目标函数来创建线程。
```python
  import threading

# 创建一个线程并指定目标函数
def thread_function(name):
    print(f"Thread {name} is running")

thread = threading.Thread(target=thread_function, args=("TestThread",))
thread.start()
thread.join()
```
### 5.3 RLock类
  RLock类是可重入锁，允许同一个线程多次获取锁，防止死锁。
```python
rlock = threading.RLock()

def reentrant_function():
    with rlock:
        # 可以在此函数内多次调用rlock.acquire()
        pass
  ```
一个简单的例子
```python
import threading
import time

def worker():
    print("Thread starting")
    time.sleep(2)
    print("Thread finishing")

threads = []
for i in range(5):
    t = threading.Thread(target=worker)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("All threads finished")
  ```
创建了5个线程，每个线程放入threads中，然后同时运行至结束

### 5.4 线程锁
当多线程同时执行时，由于threading模块的中线程的变量和数据结构共享，可能会出现多个线程同时修改一个数据的情况，这绝对是不行的。

为了将各个线程同步，我们引入线程锁的概念。当某个线程访问数据时，先对其加锁，其他线程若再想访问这个数据就会被阻塞，直到前一个线程解锁释放。在threading模块中，加锁和释放锁主要使用Lock类，使用其中的acquire()和release()方法：

```python
Lock = threading.Lock()  # 在threading模块中获得锁类
Lock.acquire()  # 设置锁
Lock.release()  # 释放锁
  ```

### 5.5 前台线程与后台线程
前台线程表示当所有的前台线程都执行完毕时，整个程序才退出。将daemon参数设定为True是表示线程是一个后台线程，此时主进程结束时，所有未执行完成的后台线程也都会直接自动结束。

### 5.6 练习 
  完成多线程下载 baidu.com 的html数据下载
```python
import threading
import requests

def download_html(index):
    """
    下载 baidu.com 的首页 HTML 数据，并输出前100个字符作为示例。
    """
    response = requests.get('https://www.baidu.com')
    print(f"线程 {index}: baidu.com 的首页 HTML 的前100个字符：\n{response.text[:100]}\n")

# 创建线程
thread1 = threading.Thread(target=download_html, args=(1, ))
thread2 = threading.Thread(target=download_html, args=(2, ))

# 启动线程
thread1.start()
thread2.start()

# 等待两个线程执行结束
thread1.join()
thread2.join()

print("两个线程下载完成。")
  ```

## 第六章 redis
### 6.1 基础配置
```python
pip install redis

import redis

# 连接到本地的Redis服务器
r = redis.Redis(host='localhost', port=6379, db=0)
```
### 6.2 增删查改操作

增
```python
# 添加一个键值对
r.set('name', 'Alice')

# 添加一个哈希
r.hset('user:1000', 'name', 'Alice')
r.hset('user:1000', 'age', 30)
```
查
```python
# 读取键的值
name = r.get('name')
print(name.decode('utf-8'))  # 输出: Alice

# 读取哈希的值
user_name = r.hget('user:1000', 'name')
user_age = r.hget('user:1000', 'age')
print(user_name.decode('utf-8'))  # 输出: Alice
print(int(user_age))  # 输出: 30
```
改
```python
# 更新键的值
r.set('name', 'Bob')

# 更新哈希的字段
r.hset('user:1000', 'age', 31)
```
删
```python
# 删除一个键
r.delete('name')

# 删除哈希的字段
r.hdel('user:1000', 'age')
```
### 6.3 进阶操作

如何在哈希中添加多个内容
```python
import redis
import json

# 连接到本地的Redis服务器
r = redis.Redis(host='localhost', port=6379, db=0)

# 创建一个包含多个名字的列表
names = ['Alice', 'Bob', 'Charlie']

# 将列表序列化为JSON字符串
names_json = json.dumps(names)

# 将JSON字符串存储到哈希字段中
r.hset('user:1002', 'names', names_json)

# 读取并反序列化JSON字符串
stored_names_json = r.hget('user:1002', 'names')
stored_names = json.loads(stored_names_json)
print(stored_names)  # 输出: ['Alice', 'Bob', 'Charlie']
```
修改一个哈希有多个元素的方法,先返回为json的形式,再操作
```python
import redis
import json

# 连接到本地的Redis服务器
r = redis.Redis(host='localhost', port=6379, db=0)

# 初始添加多个名字到哈希字段中（JSON序列化）
names = ['Alice', 'Bob', 'Charlie']
r.hset('user:1002', 'names', json.dumps(names))

# 读取哈希字段并反序列化为列表
stored_names_json = r.hget('user:1002', 'names')
stored_names = json.loads(stored_names_json)

# 修改列表中的一个名字（例如，将'Bob'修改为'David'）
index_to_modify = stored_names.index('Bob')
stored_names[index_to_modify] = 'David'

# 将修改后的列表重新序列化为JSON字符串，并存储回哈希字段中
r.hset('user:1002', 'names', json.dumps(stored_names))

# 验证修改结果
updated_names_json = r.hget('user:1002', 'names')
updated_names = json.loads(updated_names_json)
print(updated_names)  # 输出: ['Alice', 'David', 'Charlie']
```
使用mapping添加多个
```python
import redis

# 连接到本地的Redis服务器
r = redis.Redis(host='localhost', port=6379, db=0)

# 添加一些示例数据
users = [
    {'id': 1001, 'name': 'Alice', 'age': 30},
    {'id': 1002, 'name': 'Bob', 'age': 25},
    {'id': 1003, 'name': 'Charlie', 'age': 35}
]

# 将用户数据存储到Redis中
for user in users:
    user_key = f"user:{user['id']}"
    r.hset(user_key, mapping={'name': user['name'], 'age': user['age']})

# 获取所有用户的哈希字段值
for user in users:
    user_key = f"user:{user['id']}"
    user_info = r.hgetall(user_key)
    
    # 打印用户信息
    print(f"User ID: {user['id']}")
    for key, value in user_info.items():
        print(f'  {key.decode("utf-8")}: {value.decode("utf-8")}')
```

```python

```

```python

```

```python

```

  
