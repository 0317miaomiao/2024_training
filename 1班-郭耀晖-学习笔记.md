- [学习记录](#学习记录)
  - [第一章 Git的学习](#第一章-git的学习)
    - [1.1 Git的工作流程](#11-git的工作流程)
    - [1.2 Git工作区、暂存区和版本库](#12-git工作区暂存区和版本库)
    - [1.3 Git创建仓库](#13-git创建仓库)
    - [1.4 Git的基本操作](#14-git的基本操作)
    - [1.5 Git的分支管理](#15-git的分支管理)
    - [1.6 Git标签](#16-git标签)
    - [1.7 Github实操](#17-github实操)
  - [第二章 Linux 学习](#第二章-linux-学习)
    - [2.1 文件的属性](#21-文件的属性)
    - [2.2 目录的操作](#22-目录的操作)
    - [2.3 Vim的使用](#23-vim的使用)
    - [2.4 Shell的使用](#24-shell的使用)
  - [第三章 Docker学习](#第三章-docker学习)
    - [3.1 成功在Ubuntu上安装Docker](#31-成功在ubuntu上安装docker)
    - [3.2 成功安装mysql](#32-成功安装mysql)
    - [3.3 成功安装redis](#33-成功安装redis)
  - [第四章 在python中使用mysql](#第四章-在python中使用mysql)
    - [4.1 使用SQLAlchemy Core](#41-使用sqlalchemy-core)
      - [4.1.1 定义元数据和表然后连接](#422-定义元数据和表然后连接)
      - [4.1.2 增](#423-增)
    - [4.2 使用SQLAlchemy ORM](#43-使用sqlalchemy-orm)
    - [4.3 一对多与多对多关系](#44-一对多与多对多关系)
    


# 学习记录
## 第一章 Git的学习
### 1.1 Git的工作流程
  Git的主要功能在于我们能从已有的数据库中克隆工作副本，并且修改后再次上传

### 1.2 Git工作区暂存区和版本库
  工作区：你在电脑里能看到的目录
  暂存区：一般存放在 .git 目录下的 index 文件（.git/index）中

  当对工作区修改（或新增）的文件执行 **git add** 命令时，暂存区的目录树被更新
  当执行提交操作 **git commit**时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。
  当执行 **git reset HEAD** 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。
  当执行 **git rm --cached <file>** 命令时，会直接从暂存区删除文件，工作区则不做出改变。

### 1.3 Git创建仓库
  (1) **git init** 初始化，生成一个 .git 目录  
  (2) 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：  
  $ git add *.c  
  $ git add README  
  $ git commit -m '初始化项目版本'  
  (3) 克隆操作 git clone <repo> <directory> repo:Git 仓库 directory:本地目录  

### 1.4 Git的基本操作
  **git add**	添加文件到暂存区  
  **git status**	查看仓库当前的状态，显示有变更的文件。  
  **git diff**	比较文件的不同，即暂存区和工作区的差异。  
  **git commit**	提交暂存区到本地仓库。  
  **git reset**	回退版本。  
  **git rm**	将文件从暂存区和工作区中删除。  
  **git mv**	移动或重命名工作区文件。
  **git checkout**	分支切换。


### 1.5 Git的分支管理
  (1) 创建分支 git branch  
  (2) 切换分支 git checkout  
  (3) 列出分支 git branch  
  (4) 删除分支 git branch -d (branchname)  

### 1.6 Git标签
  $ git tag -a v1.0  -a 选项意为"创建一个带注解的标签

### 1.7 Github实操
  成功在本地克隆git仓库，并且实现代码的上传与下载！

存在的疑问：使用 git merge 时，为什么会发生冲突，冲突该怎么解决?

## 第二章 Linux 学习  

### 2.1 文件的属性
当为 **d** 则是目录  
当为 **-** 则是文件  
若是 **l** 则表示为链接文档(link file)  
若是 **b** 则表示为装置文件里面的可供储存的接口设备  
若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标  

### 2.2 目录的操作
(1) **pwd**：显示目前的目录  
(2) **mkdir**：创建一个新的目录  
(3) **rmdir**：删除一个空的目录   
(4) **cp**: 复制文件或目录  
(5) **mv**: 移动文件与目录，或修改文件与目录的名称   

### 2.3 Vim的使用
基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）

### 2.4 Shell的使用
#### 2.4.1 传递参数
我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数

#### 2.4.2 使用定义好的变量
使用一个定义过的变量，只要在变量名前面加美元符号即可，echo $your_name

#### 2.4.3 Shell echo命令
用于字符串的输出: echo string

#### 2.4.4 Shell流程控制
if condition
then
    command1 
    command2
    ...
    commandN 
fi
其余的详细见讲解手册

### 总结
在ubuntu 系统中使用vim生成了.sh 文件，并且改变了其权限，并且完成了echo，数学运算等一系列操作

## 第三章 Docker学习
### 3.1 成功在Ubuntu上安装Docker
### 3.2 成功安装mysql

   通过docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql运行sql  ####不需要重复进行  
   通过docker start 02fdb64e0e51c9b9b23c087568444f58e8228a95d68e3d6f8ed009410c76fb33  进行激活  
   通过docker exec -it mysql-test mysql -u root -p 进入mysql内部

#### 3.2.1 mysql的命令
    1. 创建数据库： CREATE DATABASE my_database;  
    2. 选择数据库：USE my_database;  
    3. 创建表：CREATE TABLE my_table (  
    id INT AUTO_INCREMENT PRIMARY KEY,  
    name VARCHAR(255) NOT NULL,  
    age INT NOT NULL  
);  
    4. 插入数据：INSERT INTO my_table (name, age) VALUES ('Alice', 30);  
    5. 查询数据： SELECT * FROM my_table; SELECT name, age FROM my_table;  
    6. 更新数据: UPDATE my_table SET age = 31 WHERE name = 'Alice';  
    7. 删除表和数据库: DROP TABLE my_table; DROP DATABASE my_database;  
    8. 修改表结构：ALTER TABLE my_table ADD COLUMN email VARCHAR(255);



 ### 3.3 成功安装redis
    通过 docker start 838e0ee6499429cbc66eeef7579608bf61156ab182451ada706d87d8622c2e0f进行激活  
    通过 docker exec -it redis-test /bin/bash  进入内部，开始操作  
    通过 redis-cli进行激活， 然后就可以使用  

#### 3.3.1 redis命令
    1. 设置键值对：SET mykey "Hello, Redis"  
    2. 获取键值对：GET mykey  
    3. 检查键是否存在：EXISTS mykey  
    4. 添加元素到列表：LPUSH mylist "element1"  
                      LPUSH mylist "element2"  
    5. 获取列表中的元素：LRANGE mylist 0 -1
    6. 添加元素到集合： SADD myset "member1"  
                       SADD myset "member2"  
    7. 获取集合中的所有元素：SMEMBERS myset  
    8. 设置哈希字段： HSET myhash field1 "value1"  
                     HSET myhash field2 "value2"  
    9. 获取哈希字段：HGET myhash field1  
    10. 添加元素到有序集合：ZADD myzset 1 "member1"   
                          ZADD myzset 2 "member2"  
    11. 获取有序集合中的元素： ZRANGE myzset 0 -1 WITHSCORES  
    12. 获取有序集合中元素的排名：ZRANK myzset "member1"  
    
## 第四章 在python中使用mysql
### 4.1 使用SQLAlchemy Core
  SQLAlchemy Core包含了SQL 表达式语言和 SQL 构建器，可以直接与数据库进行交互。
    
  首先我们进行包的下载
  ```python
  pip install SQLAlchemy
  ```
#### 连接数据库
  ```python
  from sqlalchemy import create_engine

  # 创建数据库连接
  engine = create_engine('sqlite:///example.db', echo=True)
  ```
其中echo=True可以让我们查看日志，便于操作

#### 4.2.2 定义元数据和表然后连接
```python
from sqlalchemy import Table, Column, Integer, String, MetaData

metadata = MetaData()

users = Table('users', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String),
    Column('age', Integer)
)
# 创建表
metadata.create_all(engine)

# 创建连接
conn = engine.connect()
  ```
#### 4.2.3 增 

```python
from sqlalchemy import insert

# 单条插入
ins = users.insert().values(name='John Doe', age=30)
conn.execute(ins)

# 批量插入
conn.execute(users.insert(), [
    {'name': 'Alice', 'age': 28},
    {'name': 'Bob', 'age': 24},
    {'name': 'Charlie', 'age': 30}
])
  ```
#### 4.2.4 查
```python
from sqlalchemy import select

# 查询所有数据
s = select([users])
result = conn.execute(s)

for row in result:
    print(row)
  ```
输出为 :(1, 'John Doe', 30)  
(2, 'John Doe', 30)  
(3, 'Alice', 28)  
(4, 'Bob', 24)  
(5, 'Charlie', 30)  

#### 4.2.5 改
```python
from sqlalchemy import update

# 更新数据
upd = update(users).where(users.c.name == 'John Doe').values(age=35)
conn.execute(upd)
  ```
#### 4.2.6 删
```python
from sqlalchemy import delete

# 删除数据
del_stmt = delete(users).where(users.c.name == 'John Doe')
conn.execute(del_stmt)
  ```
### 4.3 使用SQLAlchemy ORM

#### 4.3.1 定义模型和创建表
```python
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String
from sqlalchemy.orm import sessionmaker

# 创建数据库连接
engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

# 定义模型
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)

# 创建表
Base.metadata.create_all(engine)
  ```
#### 4.3.2 创建会话
```python
Session = sessionmaker(bind=engine)
session = Session()
2.3 增 (Insert)
  ```
# 4.3.3 增

```python
new_user = User(name='Jane Doe', age=25)
session.add(new_user)
session.commit()

# 批量插入
users = [
    User(name='Alice', age=28),
    User(name='Bob', age=24),
    User(name='Charlie', age=30)
]
session.add_all(users)
session.commit()
  ```
在这里展示如何批量插入数据，同时也可以发现使用SQLAlchemy ORM非常的方便

#### 4.3.4 查
```python
# 查询所有数据
for user in session.query(User).all():
    print(user.name, user.age)

# 带条件查询
user = session.query(User).filter_by(name='Alice').first()
print(user.name, user.age)
  ```
可以通过filter_by来有针对性的查找数据

#### 4.3.5 改
```python
# 更新数据
user = session.query(User).filter_by(name='Alice').first()
user.age = 29
session.commit()
  ```
#### 4.3.6 删
```python
# 删除数据
user = session.query(User).filter_by(name='Bob').first()
session.delete(user)
session.commit()
  ```
### 4.4 一对多与多对多关系
#### 4.4.1 一对多关系
```python
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)
    addresses = relationship("Address", back_populates="user")

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="addresses")

# 创建表
Base.metadata.create_all(engine)

# 创建会话
Session = sessionmaker(bind=engine)
session = Session()

# 插入数据
new_user = User(name='John Doe', age=30, addresses=[
    Address(email_address='john.doe@example.com'),
    Address(email_address='john.doe@work.com')
])
session.add(new_user)
session.commit()

# 查询数据
user = session.query(User).filter_by(name='John Doe').first()
print(user.name, user.age)
for address in user.addresses:
    print(address.email_address)
  ```
在这个例子中，定义了一种一对多的关系：一个 User 可以有多个 Address，而一个 Address 只能属于一个 User

可以理解为 Address就是User的一个子集，而ForeignKey('users.id')代表了address受到 user中的id的制约，不能插入user中没有的id
```python
# 尝试插入一个无效的地址（无效的 user_id）
invalid_address = Address(email_address='invalid@example.com', user_id=999)
session.add(invalid_address)
try:
    session.commit()
except Exception as e:
    session.rollback()
    print(f"Error: {e}")
  ```
这样子做可以有效的放置插入到了没有用的部位

#### 4.4.1 多对多关系

需要一个关联表来实现多对多关系

```python
from sqlalchemy import Table

association_table = Table('association', Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id')),
    Column('group_id', Integer, ForeignKey('groups.id'))
)

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    groups = relationship("Group", secondary=association_table, back_populates="users")

class Group(Base):
    __tablename__ = 'groups'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    users = relationship("User", secondary=association_table, back_populates="groups")

  ```

```python

  ```

```python

  ```

```python

  ```

```python

  ```



  
